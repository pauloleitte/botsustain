var EventEmitter, NET, Stream,
  __hasProp = Object.prototype.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

NET = require('net');

EventEmitter = require('events').EventEmitter;

Stream = require('stream').Stream;

exports.DELIMETER = "┆";

exports.DELIMETERX = /┆/g;

exports.DELIMETER_ENC = "&9478;";

exports.DELIMETER_ENCX = /&9478;/g;

exports.PART_DELIMETER = "∷";

exports.PART_DELIMETERX = /∷/g;

exports.PART_DELIMETER_ENC = "&8759;";

exports.PART_DELIMETER_ENCX = /&8759;/g;

exports.encode = function(str) {
  var rv;
  rv = str.replace(exports.PART_DELIMETERX, exports.PART_DELIMETER_ENC).replace(exports.DELIMETERX, exports.DELIMETER_ENC);
  return rv;
};

exports.decode = function(str) {
  var rv;
  rv = str.replace(exports.PART_DELIMETER_ENCX, exports.PART_DELIMETER).replace(exports.DELIMETER_ENCX, exports.DELIMETER);
  return rv;
};

exports.Server = (function(_super) {

  __extends(Server, _super);

  function Server(aSpec, aListener) {
    var server,
      _this = this;
    this.listener = aListener;
    this.connections = [];
    this.channels = [];
    server = this;
    this.tcpServer = NET.createServer(aSpec, function(connection) {
      var channel, parser, _i, _len, _ref;
      server.connections.push(connection);
      parser = new exports.IncomingConnection({
        emitter: server
      });
      connection.pipe(parser);
      _ref = server.channels;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        channel = _ref[_i];
        channel.pipe(connection);
      }
    });
    this.tcpServer.on('error', function(err) {
      return _this.emit('error', err);
    });
    this.tcpServer.on('close', function(err) {
      return _this.emit('close');
    });
    this.tcpServer.on('listening', function(err) {
      return _this.emit('listening');
    });
  }

  Server.prototype.listen = function() {
    this.tcpServer.listen.apply(this.tcpServer, arguments);
  };

  Server.prototype.createChannel = function(aName) {
    var channel, connection, _i, _len, _ref;
    channel = new exports.Channel({
      name: aName
    });
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      channel.pipe(connection);
    }
    this.channels.push(channel);
    return channel;
  };

  Server.prototype.address = function() {
    return this.tcpServer.address();
  };

  Server.prototype.close = function() {
    var connection, _i, _len, _ref;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      connection.end();
    }
    this.tcpServer.close();
  };

  return Server;

})(EventEmitter);

exports.Server.prototype.subscribe = exports.Server.prototype.addListener;

exports.IncomingConnection = (function(_super) {

  __extends(IncomingConnection, _super);

  function IncomingConnection(aSpec) {
    this.emitter = aSpec.emitter;
    this.writable = true;
    this.buffer = '';
  }

  IncomingConnection.prototype.flush = function(aChannel, aMessage) {
    this.emitter.emit(aChannel, aMessage);
    if (typeof this.emitter.listener === 'function') {
      this.emitter.listener(aChannel, aMessage);
    }
  };

  IncomingConnection.prototype.write = function(aChunk) {
    var channel, idx, message, parts, start;
    this.buffer += aChunk;
    start = 0;
    while ((idx = this.buffer.indexOf(exports.DELIMETER, start)) !== -1) {
      parts = this.buffer.substr(start, idx - start).split(exports.PART_DELIMETER);
      channel = exports.decode(parts[0]);
      message = exports.decode(parts[1]);
      this.flush(channel, message);
      start = idx + 1;
    }
    this.buffer = this.buffer.substr(start);
    return true;
  };

  IncomingConnection.prototype.end = function() {
    if (arguments.length > 0) this.write(data, encoding);
    this.writable = false;
  };

  IncomingConnection.prototype.destroy = function() {
    if (!this.writable) return;
    this.writable = false;
    this.emit('close');
  };

  return IncomingConnection;

})(EventEmitter);

exports.Connection = (function(_super) {

  __extends(Connection, _super);

  function Connection(args) {
    var parser,
      _this = this;
    this.tcpConnection = NET.connect.apply(NET, args);
    parser = new exports.IncomingConnection({
      emitter: this
    });
    this.tcpConnection.pipe(parser);
    this.tcpConnection.on('close', function() {
      return _this.emit('close');
    });
  }

  Connection.prototype.createChannel = function(aName) {
    var channel;
    channel = new exports.Channel({
      name: aName
    });
    channel.pipe(this.tcpConnection);
    return channel;
  };

  Connection.prototype.end = function() {
    return this.tcpConnection.end();
  };

  return Connection;

})(EventEmitter);

exports.Connection.prototype.subscribe = exports.Connection.prototype.addListener;

exports.Channel = (function(_super) {

  __extends(Channel, _super);

  function Channel(aSpec) {
    var _this = this;
    this.name = aSpec.name;
    this.queue = [];
    this.receivedEnd = false;
    this.writable = true;
    this.readable = true;
    this.paused = false;
    this.bytesWritten = 0;
    this.on('error', function(err) {
      _this.writable = false;
      _this.readable = false;
      if (_this.listeners.length < 2) throw err;
    });
  }

  Channel.prototype.flush = function() {
    var chunk;
    if (!this.queue.length) {
      if (this.receivedEnd) this.readable = false;
      if (!this.writable) this.emit('close');
      return;
    }
    if (this.paused) return;
    chunk = this.queue.shift();
    this.emit('data', chunk);
    this.bytesWritten += chunk.length;
    this.flush();
  };

  Channel.prototype.write = function(aMessage) {
    var channel, data, message;
    channel = exports.encode(this.name);
    message = exports.encode(aMessage);
    data = "" + channel + exports.PART_DELIMETER + message + exports.DELIMETER;
    this.queue.push(new Buffer(data, 'utf8'));
    this.flush();
    return true;
  };

  Channel.prototype.pause = function() {
    this.paused = true;
  };

  Channel.prototype.resume = function() {
    this.paused = false;
    this.flush();
  };

  Channel.prototype.end = function(aMessage) {
    if (arguments.length > 0) this.write(aMessage);
    this.receivedEnd = true;
    this.flush();
    this.writable = false;
  };

  Channel.prototype.destroy = function() {
    if (!this.writable && !this.readable) return;
    this.writable = false;
    this.readable = false;
    this.emit('close');
  };

  return Channel;

})(Stream);

exports.Channel.prototype.publish = exports.Channel.prototype.write;

exports.Channel.prototype.destroySoon = exports.Channel.prototype.end;

exports.createServer = function(opts, listener) {
  return new exports.Server(opts, listener);
};

exports.connect = function() {
  return new exports.Connection(arguments);
};
